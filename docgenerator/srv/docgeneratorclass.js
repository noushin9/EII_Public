const fs = require("fs");
const path = require("path");
const {
  Document,
  Packer,
  Paragraph,
  TableOfContents,
  HeadingLevel,
  TextRun,
  Table,
  TableRow,
  TableCell,
  Footer,
  PageNumber,
  AlignmentType,
  WidthType,
  ImageRun,
} = require("docx");
const { Integer } = require("@sap/cds/lib/core/classes");

class TemplateDocgenerator {
  constructor(options = {}) {
    this.options = options;

    this.titleStyle = { size: 28, bold: true };
    this.headingStyle = { size: 20, bold: true };
    this.normalStyle = { size: 22 };
    this.payload = options.payload || {};
    this.creator = options.creator || "Autogenerated by DocGenerator";
  }

  _textBlockParagraphs(text) {
    if (!text) return [];
    return String(text)
      .split(/\r?\n/)
      .map(
        (line) =>
          new Paragraph({
            children: [
              new TextRun({ text: line || "", size: this.normalStyle.size }),
            ],
          })
      );
  }

  _heading(text, level = 1) {
    const headingLevel =
      level === 1
        ? HeadingLevel.HEADING_1
        : level === 2
        ? HeadingLevel.HEADING_2
        : HeadingLevel.HEADING_3;
    return new Paragraph({
      text: text || "",
      heading: headingLevel,
    });
  }

  _buildPropertyTable(rows = []) {
    const tableRows = rows.map(
      (r) =>
        new TableRow({
          children: [
            new TableCell({
              width: { size: 30, type: WidthType.PERCENTAGE },
              children: [new Paragraph({ text: r.label || "", bold: true })],
            }),
            new TableCell({
              width: { size: 70, type: WidthType.PERCENTAGE },
              children: this._textBlockParagraphs(r.value || ""),
            }),
          ],
        })
    );

    return new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: tableRows,
    });
  }
  _buildcsvTable(data = [], columns = []) {
    if (!data.length || !columns.length) return null;

    const rows = data.map((item) => {
      return columns.map((col) => {
        const value = item[col] || "";
        return new TableCell({
          children: [new Paragraph({ text: value })],
        });
      });
    });

    return new Table({
      rows: [
        new TableRow({
          children: columns.map(
            (col) =>
              new TableCell({
                children: [new Paragraph({ text: col, bold: true })],
              })
          ),
        }),
        ...rows.map((row) => new TableRow({ children: row })),
      ],
    });
  }

  /**
   * Main generate function
   * @param {Object} data - JSON input
   * @param {string} outputPath - file path to write .docx
   * @returns {Promise<Buffer>} - resolves to buffer (also writes to file if outputPath provided)
   */
  async generate(data = {}, outputPath = null) {
    // Document sections based on uploaded template structure.
    const sections = [{ properties: {}, children: [] }];

    // Convenience
    const c = sections[0].children;
    //Table of Contents
    c.push(
      new Paragraph({
        text: "Table of Contents",
        heading: HeadingLevel.HEADING_1,
        alignment: AlignmentType.CENTER,
        spacing: { after: 300 },
      })
    );
    c.push(
      new Paragraph({
        children: [
          new TableOfContents("Table of Contents", {
            headingStyleRange: "1-3",
            hyperlink: true,
            sequenceAndPageNumbersSeparator: new TextRun({ text: " . " }),
          }),
        ],
        spacing: { after: 300 },
      })
    );
    c.push(new Paragraph({ text: "" }));
    // Title block (project + customer)
    const projectName = data.projectName || "< Project Name >";
    const customerName = data.customerName || "< Customer Name >";
    c.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Project Functional Specification Document",
            bold: true,
            size: 36,
          }),
        ],
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({ text: "" }),
      new Paragraph({
        children: [
          new TextRun({ text: `Project Name: ${projectName}`, bold: true }),
        ],
      }),
      new Paragraph({
        children: [
          new TextRun({ text: `Customer Name: ${customerName}`, bold: true }),
        ],
      }),
      new Paragraph({ text: "" })
    );

    // Add a simple "Project Identification" table if provided
    if (data.projectIdentification) {
      c.push(this._heading("Project Identification", 2));
      const rows = [];
      for (const item of data.projectIdentification) {
        rows.push({ label: item.label, value: item.value });
      }
      if (rows.length === 0) {
        rows.push({ label: "Project Name", value: projectName });
        rows.push({ label: "Customer Name", value: customerName });
      }
      c.push(this._buildPropertyTable(rows));
    }

    // Revision history
    if (data.revisionHistory && data.revisionHistory.length) {
      c.push(this._heading("Revision history", 2));
      // Build a table with columns: Author | Version | Date | Status | Location
      const headerRow = new TableRow({
        children: [
          "Author",
          "Version",
          "Date",
          "Status",
          "Document Location",
        ].map(
          (h) =>
            new TableCell({
              children: [new Paragraph({ text: h, bold: true })],
            })
        ),
      });

      const revRows = data.revisionHistory.map(
        (r) =>
          new TableRow({
            children: [
              new TableCell({
                children: this._textBlockParagraphs(r.author || ""),
              }),
              new TableCell({
                children: this._textBlockParagraphs(r.version || ""),
              }),
              new TableCell({
                children: this._textBlockParagraphs(r.date || ""),
              }),
              new TableCell({
                children: this._textBlockParagraphs(r.status || ""),
              }),
              new TableCell({
                children: this._textBlockParagraphs(r.location || ""),
              }),
            ],
          })
      );

      const revTable = new Table({
        rows: [headerRow, ...revRows],
        width: { size: 100, type: WidthType.PERCENTAGE },
      });
      c.push(revTable);
    }

    // Overview section and sub-sections
    c.push(this._heading("1. Overview", 2));
    const overviewSections = [
      { title: "a. Business Process Overview", key: "businessProcessOverview" },
      { title: "b. Functional Overview", key: "functionalOverview" },
      { title: "c. Alternatives Considered", key: "alternativesConsidered" },
      {
        title: "d. Business Benefit and Consequence of proposed Solution",
        key: "businessBenefit",
      },
      { title: "e. Assumptions", key: "assumptions" },
      {
        title: "f. Relationship to other documentation.",
        key: "relationshipToOtherDocumentation",
      },
    ];

    for (const s of overviewSections) {
      c.push(new Paragraph({ text: s.title, spacing: { before: 200 } }));
      const content = data[s.key] || "";
      c.push(...this._textBlockParagraphs(content));
    }

    // Functional Design
    c.push(this._heading("2. FunCtional Design", 2));
    // User Story block
    c.push(new Paragraph({ text: "a. User Story" }));
    if (data.userStories && data.userStories.length) {
      for (const us of data.userStories) {
        c.push(
          new Paragraph({
            text: `${us.id ? `${us.id} - ` : ""}${us.title || ""}`,
            bullet: { level: 0 },
          })
        );
        c.push(...this._textBlockParagraphs(us.description || ""));
      }
    } else {
      c.push(...this._textBlockParagraphs(data.userStory || ""));
    }

    // Functional Design details
    c.push(new Paragraph({ text: "b. Functional Design" }));
    c.push(...this._textBlockParagraphs(data.functionalDesign || ""));

    // Constraints/Decisions
    c.push(new Paragraph({ text: "c. Constraints/Decisions" }));
    if (Array.isArray(data.constraints) && data.constraints.length) {
      for (const con of data.constraints) {
        c.push(new Paragraph({ text: `- ${con}`, bullet: { level: 0 } }));
      }
    } else {
      c.push(...this._textBlockParagraphs(data.constraintsText || ""));
    }

    // Delivery
    c.push(this._heading("3. Delivery", 2));
    c.push(new Paragraph({ text: "" }));

    // Tasks to be performed by SAP Ariba / Customer / Partner -> tables
    const deliveryBuckets = [
      { title: "Tasks to be performed by SAP Ariba", key: "tasksBySapAriba" },
      { title: "Tasks to be performed by <Customer>", key: "tasksByCustomer" },
      { title: "Tasks to be performed by <Partner>", key: "tasksByPartner" },
    ];

    for (const b of deliveryBuckets) {
      c.push(new Paragraph({ text: b.title }));
      const tasks = data[b.key] || [];
      if (tasks.length) {
        const header = new TableRow({
          children: ["Task", "Description", "Dependency"].map(
            (h) =>
              new TableCell({
                children: [new Paragraph({ text: h, bold: true })],
              })
          ),
        });
        const rows = tasks.map(
          (t) =>
            new TableRow({
              children: [
                new TableCell({
                  children: this._textBlockParagraphs(t.task || ""),
                }),
                new TableCell({
                  children: this._textBlockParagraphs(t.description || ""),
                }),
                new TableCell({
                  children: this._textBlockParagraphs(t.dependency || ""),
                }),
              ],
            })
        );
        c.push(
          new Table({
            rows: [header, ...rows],
            width: { size: 100, type: WidthType.PERCENTAGE },
          })
        );
      } else {
        c.push(
          ...this._textBlockParagraphs(`No tasks provided for ${b.title}`)
        );
      }
    }

    // Footer / Copyright block (taken from template)
    c.push(new Paragraph({ text: "" }));
    c.push(new Paragraph({ text: "www.sap.com/contactsap" }));
    c.push(
      new Paragraph({
        text: "© 2018 SAP SE or an SAP affiliate company. All rights reserved.",
      })
    );
    c.push(new Paragraph({ text: "" }));
    const docGen = new Document({
      creator: this.creator,
      title: "Project Functional Specification Document",
      description: "Generated functional specification document",
      sections: sections,
    });
    // Pack and output
    const buffer = await Packer.toBuffer(docGen);

    return buffer;
  }
}
// class DocGenerator {
//   constructor(payloadOrArray = [], options = {}) {
//     this.items = Array.isArray(payloadOrArray)
//       ? payloadOrArray
//       : [payloadOrArray];
//     this.options = options;
//     this.creator = options.creator || "Autogenerated by DocGenerator";
//   }

//   static _prettyBool(v) {
//     return v === true || v === 1
//       ? "Yes"
//       : v === false || v === 0
//       ? "No"
//       : String(v);
//   }

//   _htmlToText(html) {
//     return html
//       .replace(/<[^>]+>/g, "")
//       .replace(/\s+/g, " ")
//       .trim();
//   }
//   _buildForItem(item) {
//     const title = new Paragraph({
//       children: [
//         new TextRun({
//           text: item.displayName || "Configuration Item",
//           color: "2E74B5",
//           bold: true,
//           size: 32,
//         }),
//       ],
//       heading: HeadingLevel.HEADING_2,
//       alignment: AlignmentType.CENTER,
//       spacing: { after: 200 },
//     });

//     const subtitle = new Paragraph({
//       children: [new TextRun({ text: item.parameterName || "", bold: true })],
//       alignment: AlignmentType.CENTER,
//       spacing: { after: 240 },
//     });

//     const value = item.parameterValue;
//     const valueText =
//       value === true ? "ENABLED" : value === false ? "DISABLED" : String(value);
//     const valueRun = new TextRun({
//       text: valueText,
//       bold: true,
//       color: value === true ? "006400" : "8B0000",
//     });
//     const badge = new Paragraph({
//       children: [
//         new TextRun({ text: "Current value: ", italics: true }),
//         valueRun,
//       ],
//       alignment: AlignmentType.CENTER,
//       spacing: { after: 300 },
//     });

//     const description = new Paragraph({
//       children: [
//         new TextRun({ text: "Description:	", bold: true }),
//         new TextRun({
//           text: (this._htmlToText(item.description) || "-").slice(0, 1000),
//         }),
//       ],
//       spacing: { after: 100 },
//     });
//     const inputPayload = {
//       projectName: "Ariba Integration 1",
//       customerName: "Acme Corp",
//       customerProject: "ACME-Ariba-001",
//       aribaSolution: "Services - Buy Channel",
//       userStory: "As a user I want X so that Y",
//       sapAribaPM: "John Ariba",
//       customerPM: "Jane Customer",
//       overview: {
//         businessProcess:
//           "We need to allow vendors to submit invoices via Ariba...",
//         functionalOverview: "High-level functional changes include A, B, C.",
//         alternatives: "Option 1: Use API; Option 2: Use manual import",
//         benefits: "Reduce manual effort by 80%",
//         assumptions: "Customer has existing Ariba instance",
//         relations: "See Leading Practice Document LP-123",
//       },
//       revisionHistory: [
//         {
//           author: "Alice",
//           docLocation: "repo/path/name",
//           version: "0.1",
//           status: "Draft",
//           date: "01-Jan-2025",
//           classification: "Internal",
//         },
//       ],
//       functionalDesign: {
//         userStories: "User story details here",
//         designNotes: "Functional changes to RICEFWD objects",
//         constraints: "No change to core Ariba APIs",
//       },
//       delivery: {
//         sapTasks: [
//           {
//             task: "Develop integration",
//             description: "Implement connector",
//             dependency: "None",
//           },
//         ],
//         customerTasks: [
//           {
//             task: "Provide sandbox",
//             description: "Provision test system",
//             dependency: "SAP tasks",
//           },
//         ],
//         partnerTasks: [],
//       },
//     };
//     // Table for properties
//     const rows = [];
//     rows.push(
//       new TableRow({
//         children: [
//           new TableCell({
//             width: { size: 40, type: WidthType.PERCENTAGE },
//             margins: { top: 100, bottom: 100, left: 100, right: 100 },
//             shading: { fill: "F2F2F2" },
//             children: [
//               new Paragraph({
//                 children: [new TextRun({ text: "Property", bold: true })],
//               }),
//             ],
//           }),
//           new TableCell({
//             width: { size: 60, type: WidthType.PERCENTAGE },
//             margins: { top: 100, bottom: 100, left: 100, right: 100 },
//             shading: { fill: "F2F2F2" },
//             children: [
//               new Paragraph({
//                 children: [new TextRun({ text: "Value", bold: true })],
//               }),
//             ],
//           }),
//         ],
//       })
//     );

//     function makeRow(prop, val) {
//       return new TableRow({
//         children: [
//           new TableCell({
//             children: [new Paragraph({ text: prop })],
//             margins: { top: 100, bottom: 100, left: 100, right: 100 },
//           }),
//           new TableCell({
//             children: [new Paragraph({ text: val })],
//             margins: { top: 100, bottom: 100, left: 100, right: 100 },
//           }),
//         ],
//       });
//     }

//     rows.push(makeRow("Parameter Type", item.parameterType || "-"));
//     rows.push(makeRow("Is Default", DocGenerator._prettyBool(item.isDefault)));
//     rows.push(
//       makeRow("Default Value", DocGenerator._prettyBool(item.defaultValue))
//     );
//     rows.push(
//       makeRow(
//         "Is Customer Editable",
//         DocGenerator._prettyBool(item.isCustomerEditable)
//       )
//     );
//     rows.push(
//       makeRow("Parameter Value", DocGenerator._prettyBool(item.parameterValue))
//     );

//     const detailsTable = new Table({
//       rows,
//       width: { size: 100, type: WidthType.PERCENTAGE },
//       borders: {
//         top: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
//         bottom: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
//         left: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
//         right: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
//         insideHorizontal: {
//           style: BorderStyle.SINGLE,
//           size: 1,
//           color: "EDEDED",
//         },
//         insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "EDEDED" },
//       },
//       margin: { top: 200, bottom: 200 },
//     });

//     const note = new Paragraph({
//       children: [
//         new TextRun({ text: "Note: ", bold: true }),
//         new TextRun({
//           text: (this._htmlToText(item.description) || "-").slice(0, 1000),
//         }),
//       ],
//       spacing: { before: 300 },
//     });

//     return { title, subtitle, badge, description, detailsTable, note };
//   }

//   async generateCombined(filename = "combined.docx") {
//     const sections = [];

//     const docChildren = [];

//     this.items.forEach((item, idx) => {
//       const built = this._buildForItem(item);

//       if (idx !== 0) {
//         docChildren.push(new Paragraph({ text: "", pageBreakBefore: false }));
//       }

//       docChildren.push(
//         built.title,
//         built.subtitle,
//         built.badge,
//         built.description,
//         built.detailsTable
//       );
//     });

//     const doc = new Document({
//       creator: this.creator,
//       title: this.options.title || "Configuration Document",
//       description:
//         this.options.description || "Generated configuration documentation",
//       sections: [
//         {
//           properties: {},
//           footers: {
//             default: new Footer({
//               children: [
//                 new Paragraph({
//                   alignment: AlignmentType.CENTER,
//                   children: [
//                     new TextRun({
//                       text: `Generated: ${new Date().toLocaleString()}`,
//                     }),
//                     new TextRun({ text: "  •  " }),
//                     new TextRun({ text: "Page " }),
//                     PageNumber.CURRENT,
//                   ],
//                 }),
//               ],
//             }),
//           },
//           children: docChildren,
//         },
//       ],
//     });

//     // Packer.toBlob(doc)
//     //   .then((blob) => {
//     //     saveAs(blob, filename);
//     //     console.log("Document created successfully");
//     //     return filename;
//     //   })
//     //   .catch((err) => {
//     //     console.error("Error creating document:", err);
//     //   });
//     // console.log("BUFFER", doc);
//     const buffer = await Packer.toBuffer(doc);
//     // let fileContent = fs.writeFileSync(filename, buffer);
//     // console.log("Document created successfully", fileContent);

//     return buffer;
//   }

//   async generateSeparate(outputDir = "output-files") {
//     if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

//     const results = [];

//     for (let i = 0; i < this.items.length; i++) {
//       const item = this.items[i];

//       const built = this._buildForItem(item);

//       const doc = new Document({
//         creator: this.creator,
//         title: item.displayName || `Item ${i + 1}`,
//         description: item.description || "",
//         sections: [
//           {
//             properties: {},
//             footers: {
//               default: new Footer({
//                 children: [
//                   new Paragraph({
//                     alignment: AlignmentType.CENTER,
//                     children: [
//                       new TextRun({
//                         text: `Generated: ${new Date().toLocaleString()}`,
//                       }),
//                       new TextRun({ text: "  •  " }),
//                       new TextRun({ text: "Page " }),
//                       PageNumber.CURRENT,
//                     ],
//                   }),
//                 ],
//               }),
//             },
//             children: [
//               built.title,
//               built.subtitle,
//               built.badge,
//               built.description,
//               built.detailsTable,
//               built.note,
//             ],
//           },
//         ],
//       });

//       const safeName = (item.parameterName || `item-${i + 1}`).replace(
//         /[\/:*?"<>|]/g,
//         "_"
//       );
//       const fname = path.join(outputDir, `${safeName}.docx`);
//       const buffer = await Packer.toBlob(doc).then((blob) => {
//         saveAs(blob, fname);
//       });
//       results.push(fname);
//     }

//     return results;
//   }
// }

// srv/utils/doc-generator.js

class DocGenerator {
  constructor(options = {}) {
    this.options = options;
    // small defaults
    this.titleSize = 32;
    this.heading1Size = 14;
    this.heading2Size = 12;
    this.normalSize = 11;
    this.font = options.font || "Arial";
  }

  _run(text, opts = {}) {
    return new TextRun(
      Object.assign(
        {
          text: String(text ?? ""),
          font: this.font,
          size: this.normalSize * 2, // docx size uses half-points: 11pt => 22
        },
        opts
      )
    );
  }

  _para(textOrRun, opts = {}) {
    if (typeof textOrRun === "string") {
      return new Paragraph(
        Object.assign(
          {
            children: [this._run(textOrRun)],
          },
          opts
        )
      );
    }
    return new Paragraph(
      Object.assign(
        { children: Array.isArray(textOrRun) ? textOrRun : [textOrRun] },
        opts
      )
    );
  }
  _spacingAfter(aspace) {
    return new Paragraph({ text: "", spacing: { after: aspace } });
  }

  _spacingBefore(bspace) {
    return new Paragraph({ text: "", spacing: { before: bspace } });
  }

  _heading(text, level = 1) {
    const size = level === 1 ? this.heading1Size : this.heading2Size;
    return new Paragraph({
      text: "",
      heading: level === 1 ? HeadingLevel.HEADING_1 : HeadingLevel.HEADING_2,
      children: [
        new TextRun({ text, bold: true, font: this.font, size: size * 2 }),
      ],
    });
  }
  _headingWithBullet(text, level) {
    return new Paragraph({
      text: text || "",
      bullet: { level: level || 0 },
      spacing: { before: 100 },
    });
  }
  _buildKeyValueTable(kvArray = []) {
    const rows = kvArray.map(
      (item) =>
        new TableRow({
          children: [
            new TableCell({
              width: { size: 30, type: WidthType.PERCENTAGE },
              children: [this._para(item.label || "")],
            }),
            new TableCell({
              width: { size: 70, type: WidthType.PERCENTAGE },
              children: [this._para(item.value || "")],
            }),
          ],
        })
    );
    // header row
    const header = new TableRow({
      children: [
        new TableCell({ children: [this._para("Field")] }),
        new TableCell({ children: [this._para("Value")] }),
      ],
    });
    return new Table({
      rows: [header, ...rows],
      width: { size: 100, type: WidthType.PERCENTAGE },
    });
  }

  _buildSimpleTable(headers = [], rowsData = []) {
    const headerRow = new TableRow({
      children: headers.map(
        (h) => new TableCell({ children: [this._para(h)] })
      ),
    });
    const rows = rowsData.map(
      (r) =>
        new TableRow({
          children: headers.map(
            (_, i) => new TableCell({ children: [this._para(r[i] ?? "")] })
          ),
        })
    );
    return new Table({
      rows: [headerRow, ...rows],
      width: { size: 100, type: WidthType.PERCENTAGE },
    });
  }

  /**
   * Generate DOCX buffer from payload (JS object).
   * @param {Object} payload
   * @returns {Promise<Buffer>}
   */
  async generateBuffer(payload = {}) {
    // if payload wrapped inside value.docpayload (like in your jsonformatter) handle that.

    const root =
      payload.docpayload ||
      payload.value?.docpayload ||
      payload.value ||
      payload;

    const doc = new Document({
      creator: this.creator,
      title: "Project Functional Specification Document",
      description: "Generated functional specification document",
      sections: [],
    });
    const pageFooter = new Footer({
      children: [
        new Paragraph({
          alignment: AlignmentType.CENTER,
          children: [
            new TextRun("Page "),
            PageNumber.CURRENT,
            new TextRun(" of "),
            PageNumber.TOTAL_PAGES,
          ],
        }),
      ],
    });

    // COVER PAGE
    doc.addSection({
      footers: { default: pageFooter },
      children: [
        this._para("", { spacing: { before: 200 } }),
        new Paragraph({
          children: [
            new TextRun({
              text: root.projectName || "Project Functional Specification",
              bold: true,
              size: this.titleSize * 2,
              font: this.font,
            }),
          ],
          alignment: AlignmentType.CENTER,
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: root.customerName || "",
              size: 14 * 2,
              font: this.font,
            }),
          ],
          alignment: AlignmentType.CENTER,
        }),
        this._para(" ", { spacing: { after: 200 } }),
        new Paragraph({
          children: [
            new TextRun({
              text: "Functional Specification Document",
              bold: true,
              size: 14 * 2,
              font: this.font,
            }),
          ],
          alignment: AlignmentType.CENTER,
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: `Generated: ${new Date()
                .toISOString()
                .replace("T", " ")
                .slice(0, 19)} UTC`,
              font: this.font,
              size: 10 * 2,
            }),
          ],

          alignment: AlignmentType.CENTER,
        }),
        this._para(" ", { spacing: { after: 400 } }),
        // Add logo as floating image so it doesn't affect layout and avoid

        new Paragraph({
          children: [
            // new ImageRun({
            //   data: fs.readFileSync(path.join(__dirname, "/public/logo.png")),
            //   transformation: { width: 700, height: 700 },
            //   floating: {
            //     horizontalPosition: {
            //       align: "center", // Centers image horizontally on the page
            //     },
            //     verticalPosition: {
            //       offset: 3000000, // Moves image down (~2.7 cm)
            //     },
            //     wrap: {
            //       type: "behindText",
            //     },
            //   },
            // }),
          ],
          alignment: AlignmentType.CENTER,
        }),
      ],
    });

    // TOC page (Word will compute page numbers when user updates the TOC)
    doc.addSection({
      children: [
        new Paragraph({
          children: [
            new TextRun({
              text: "TABLE OF CONTENTS",
              bold: true,
              size: 14 * 2,
              font: this.font,
            }),
          ],
        }),
        new TableOfContents("Table of Contents", {
          headingStyleRange: "1-3",
          hyperlink: true,
          pageNumbersEntryLevelsRange: "1-3",
          sequenceAndPageNumbersSeparator: new TextRun({
            text: " . ",
            font: this.font,
            size: this.normalSize * 2,
          }),
        }),
        new Paragraph({ children: [], pageBreakBefore: false }),
      ],
    });

    // MAIN CONTENT section - start page numbering here
    doc.addSection({
      properties: { pageNumberStart: 1 },
      footers: {
        default: new Footer({
          children: [
            new Paragraph({
              children: [
                new TextRun({
                  text: "Page ",
                  font: this.font,
                  size: this.normalSize * 2,
                }),
                PageNumber.CURRENT,
                new TextRun({
                  text: " of ",
                  font: this.font,
                  size: this.normalSize * 2,
                }),
                PageNumber.TOTAL_PAGES,
              ],
              alignment: AlignmentType.CENTER,
            }),
          ],
        }),
      },
      children: [
        // Project Identification
        this._heading("PROJECT IDENTIFICATION", 1),
        this._spacingAfter(100),
        root.projectIdentification && root.projectIdentification.length
          ? this._buildKeyValueTable(root.projectIdentification)
          : this._para("No Project Identification provided."),
        this._spacingAfter(100),

        // Revision history
        this._heading("REVISION HISTORY", 1),
        this._spacingAfter(100),
        (() => {
          const rev = root.revisionHistory || [];
          if (!rev.length) return this._para("No revision history provided.");
          // build table with Author|Version|Date|Status|Location
          const header = ["Author", "Version", "Date", "Status", "Location"];
          const rows = rev.map((r) => [
            r.author || "",
            r.version || "",
            r.date || "",
            r.status || "",
            r.location || "",
          ]);
          return this._buildSimpleTable(header, rows);
        })(),
        this._spacingAfter(100),

        // 1 Overview
        this._heading("1. OVERVIEW", 1),
        this._spacingAfter(100),
        this._heading("a. Business Process Overview", 2),
        this._spacingAfter(50),
        this._para(root.businessProcessOverview || "Not provided.", {
          bullet: { level: 1 },
        }),
        this._spacingAfter(100),
        this._heading("b. Functional Overview", 2),
        this._spacingAfter(50),
        this._para(root.functionalOverview || "Not provided.", {
          bullet: { level: 1 },
        }),
        this._spacingAfter(100),
        this._heading("c. Alternatives Considered", 2),
        this._spacingAfter(50),
        this._para(root.alternativesConsidered || "", { bullet: { level: 1 } }),
        this._spacingAfter(100),
        this._heading(
          "d. Business Benefit and Consequence of proposed Solution",
          2
        ),
        this._spacingAfter(50),
        this._para(root.businessBenefit || "", { bullet: { level: 1 } }),
        this._spacingAfter(100),
        this._heading("e. Assumptions", 2),
        this._spacingAfter(50),
        this._para(root.assumptions || "", { bullet: { level: 1 } }),
        this._spacingAfter(100),
        this._heading("f. Relationship to other documentation", 2),
        this._spacingAfter(50),
        this._para(root.relationshipToOtherDocumentation || "", {
          bullet: { level: 1 },
        }),
        this._spacingAfter(100),
        // 2 Functional Design
        this._heading("2. FUNCTIONAL DESIGN", 1),
        this._spacingAfter(100),
        root.userStories && root.userStories.length
          ? this._heading("a. User Story", 2)
          : "",
        ...(root.userStories || []).flatMap((us) => {
          return [
            new Paragraph({
              children: [
                new TextRun({
                  text: `${us.id || ""} - ${us.title || ""}`,
                  bold: true,
                  font: this.font,
                  size: this.normalSize * 2,
                }),
              ],
              bullet: { level: 0 },
            }),
            this._para(us.description || "<UserStoryDetails>", {
              bullet: { level: 1 },
            }),
            this._spacingAfter(50),
          ];
        }),

        this._heading("b. Functional Design", 2),
        this._spacingAfter(50),
        this._para(root.functionalDesign || "<FunctionalDesignDetails>", {
          bullet: { level: 1 },
        }),
        this._spacingAfter(100),
        this._heading("c. Constraints/Decisions", 2),
        this._spacingAfter(50),
        root.constraints && root.constraints.length
          ? this._para(
              "The following constraints/decisions apply to this project:"
            )
          : this._para("No constraints/decisions provided."),
        this._spacingAfter(50),
        ...(root.constraints || []).map((c) =>
          this._para(`• ${c}`, { bullet: { level: 1 } })
        ),
        this._spacingAfter(100),

        // 3 Delivery
        this._heading("3. DELIVERY", 1),
        this._spacingAfter(100),
        ...this._buildTasksSection(
          "Tasks to be performed by SAP Ariba",
          root.tasksBySapAriba || []
        ),
        this._spacingAfter(100),
        ...this._buildTasksSection(
          "Tasks to be performed by Customer",
          root.tasksByCustomer || []
        ),
        this._spacingAfter(100),
        ...this._buildTasksSection(
          "Tasks to be performed by Partner",
          root.tasksByPartner || []
        ),
        this._spacingAfter(100),

        // Guided Buying parameters
        this._heading("Guided Buying Parameters", 1),
        this._spacingAfter(100),
        this._para(
          "The following Guided Buying parameters are to be set as part of this project:"
        ),
        this._spacingAfter(50),
        root.csvGuidedBuyingParameters && root.csvGuidedBuyingParameters.length
          ? this._buildSimpleTable(
              [`${"Parameter Name"}`, "Description", "Value", "Modified By"],
              root.csvGuidedBuyingParameters.map((p) => [
                p.PARAM_NAME,
                p.PARAM_DESC,
                String(p.PARAM_VALUE),
                p.MODIFIED_BY,
              ])
            )
          : this._para("No Guided Buying parameters provided."),
        this._spacingAfter(100),
        // SAP-editable and Customer-editable parameters
        this._heading("SAP-editable Parameters", 1),
        root.sapEditableParameters && root.sapEditableParameters.length
          ? this._buildSimpleTable(
              [
                "Parameter Name",
                "Type",
                "Customer Editable",
                "Description (truncated)",
              ],
              root.sapEditableParameters.map((p) => [
                p.parameterName || "",
                p.parameterType || "",
                String(p.isCustomerEditable ?? false),
                String(p.description || "").slice(0, 300) +
                  (String(p.description || "").length > 300 ? "..." : ""),
              ])
            )
          : this._para("No Customer-editable parameters provided."),
        this._spacingAfter(100),
        this._heading("Customer-editable Parameters ", 1),
        root.customerEditableParameters &&
        root.customerEditableParameters.length
          ? this._buildSimpleTable(
              [
                "Parameter Name",
                "Type",
                "Customer Editable",
                "Description (truncated)",
              ],
              root.customerEditableParameters.map((p) => [
                p.parameterName || "",
                p.parameterType || "",
                String(p.isCustomerEditable ?? false),
                String(p.description || "").slice(0, 300) +
                  (String(p.description || "").length > 300 ? "..." : ""),
              ])
            )
          : this._para("No Customer-editable parameters provided."),
      ],
    });
    // const footerTable = new Table({
    //   rows: [first, last],
    //   width: {
    //     size: 100,
    //     type: WidthType.PERCENTAGE,
    //   },
    //   float: {
    //     relativeVerticalPosition: RelativeVerticalPosition.BOTTOM,
    //     bottomFromText: 200,
    //   },
    //   layout: TableLayoutType.FIXED,
    //   // float: {
    //   //   horizontalAnchor: TableAnchorType.MARGIN,
    //   //   verticalAnchor: TableAnchorType.MARGIN,
    //   //   relativeHorizontalPosition: RelativeHorizontalPosition.LEFT,
    //   //   relativeVerticalPosition: RelativeVerticalPosition.OUTSIDE,
    //   //   overlap: OverlapType.NEVER,
    //   //   // topFromText: convertInchesToTwip(0.2),
    //   // },
    // });
    // doc.addSection({
    //   footers: {
    //     first: new Footer({
    //       children: [],
    //     }),
    //     default: new Footer({
    //       children: [footerTable],
    //     }),
    //   },
    // });

    // Packer to buffer
    const buffer = await Packer.toBuffer(doc);
    return buffer;
  }

  // helper for building tasks sections returns an array of paragraphs/tables
  _buildTasksSection(title, tasks = []) {
    const out = [this._heading(title, 2)];
    this._spacingAfter(100);
    if (!tasks || tasks.length === 0) {
      out.push(this._para("No tasks specified."));
      return out;
    }
    const header = ["Task", "Description", "Dependency"];
    const rows = tasks.map((t) => [
      t.task || "",
      t.description || "",
      t.dependency || "",
    ]);
    out.push(this._buildSimpleTable(header, rows));
    return out;
  }
}

module.exports = { DocGenerator, TemplateDocgenerator };
