// generate-docx.js
// Node.js class that generates a stylish Word (.docx) document from a payload or an array of payloads
// Uses the `docx` package (https://www.npmjs.com/package/docx)
// Usage:
//   npm install docx
//   node generate-docx.js

const fs = require("fs");
const path = require("path");
const {
  Document,
  Packer,
  Paragraph,
  TextRun,
  Table,
  TableRow,
  TableCell,
  WidthType,
  HeadingLevel,
  AlignmentType,
  BorderStyle,
  Footer,
  PageNumber,
} = require("docx");

/**
 * Class: DocGenerator
 * - Accepts either a single payload object or an array of payload objects
 * - Can generate a single combined document (each item starts on a new page)
 * - Can generate separate documents (one file per item)
 *
 * Example:
 *   const gen = new DocGenerator([payload1, payload2]);
 *   await gen.generateCombined('all.docx');
 *   await gen.generateSeparate('./out-dir');
 */
class DocGenerator {
  constructor(payloadOrArray = [], options = {}) {
    this.items = Array.isArray(payloadOrArray)
      ? payloadOrArray
      : [payloadOrArray];
    this.options = options;
    this.creator = options.creator || "Autogenerated by DocGenerator";
  }

  static _prettyBool(v) {
    return v === true || v===1 ? "Yes" : v === false || v===0 ? "No" : String(v);
  }

  _htmlToText(html) {
    
    return html.replace(/<[^>]+>/g, "").replace(/\s+/g, " ").trim();
  }
  _buildForItem(item) {
    const title = new Paragraph({
      children: [new TextRun({text:item.displayName || "Configuration Item",color:"2E74B5",bold:true, size:32})],
      heading: HeadingLevel.HEADING_2,
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 }
    });

    const subtitle = new Paragraph({
      children: [new TextRun({ text: item.parameterName || "", bold: true })],
      alignment: AlignmentType.CENTER,
      spacing: { after: 240 },
    });

    const value = item.parameterValue;
    const valueText =
      value === true ? "ENABLED" : value === false ? "DISABLED" : String(value);
    const valueRun = new TextRun({
      text: valueText,
      bold: true,
      color: value === true ? "006400" : "8B0000",
    });
    const badge = new Paragraph({
      children: [
        new TextRun({ text: "Current value: ", italics: true }),
        valueRun,
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 300 },
    });

    const description = new Paragraph({
      children: [
        new TextRun({ text: "Description:	", bold: true }),
        new TextRun({ text: (this._htmlToText(item.description) || "-").slice(0, 1000) }),
      ],
      spacing: { after: 100 },
    });

    // Table for properties
    const rows = [];
    rows.push(
      new TableRow({
        children: [
          new TableCell({
            width: { size: 40, type: WidthType.PERCENTAGE },
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
            shading: { fill: "F2F2F2" },
            children: [
              new Paragraph({
                children: [new TextRun({ text: "Property", bold: true })],
              }),
            ],
          }),
          new TableCell({
            width: { size: 60, type: WidthType.PERCENTAGE },
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
            shading: { fill: "F2F2F2" },
            children: [
              new Paragraph({
                children: [new TextRun({ text: "Value", bold: true })],
              }),
            ],
          }),
        ],
      })
    );

    function makeRow(prop, val) {
      return new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ text: prop })],
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
          }),
          new TableCell({
            children: [new Paragraph({ text: val })],
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
          }),
        ],
      });
    }

    rows.push(makeRow("Parameter Type", item.parameterType || "-"));
    rows.push(makeRow("Is Default", DocGenerator._prettyBool(item.isDefault)));
    rows.push(
      makeRow("Default Value", DocGenerator._prettyBool(item.defaultValue))
    );
    rows.push(
      makeRow(
        "Is Customer Editable",
        DocGenerator._prettyBool(item.isCustomerEditable)
      )
    );
    rows.push(
      makeRow("Parameter Value", DocGenerator._prettyBool(item.parameterValue))
    );

    const detailsTable = new Table({
      rows,
      width: { size: 100, type: WidthType.PERCENTAGE },
      borders: {
        top: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        left: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        right: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        insideHorizontal: {
          style: BorderStyle.SINGLE,
          size: 1,
          color: "EDEDED",
        },
        insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "EDEDED" },
      },
      margin: { top: 200, bottom: 200 },
    });

    const note = new Paragraph({
      children: [
        new TextRun({ text: "Note: ", bold: true }),
        new TextRun({ text: (this._htmlToText(item.description) || "-").slice(0, 1000) }),
      ],
      spacing: { before: 300 },
    });

    return { title, subtitle, badge, description, detailsTable, note };
  }

  async generateCombined(filename = "combined.docx") {
    const sections = [];

    const docChildren = [];

    this.items.forEach((item, idx) => {
      const built = this._buildForItem(item);

      if (idx !== 0) {
        docChildren.push(new Paragraph({ text: "", pageBreakBefore: false }));
      }

      docChildren.push(
        built.title,
        built.subtitle,
        built.badge,
        built.description,
        built.detailsTable
      );
    });

    const doc = new Document({
      creator: this.creator,
      title: this.options.title || "Configuration Document",
      description:
        this.options.description || "Generated configuration documentation",
      sections: [
        {
          properties: {},
          footers: {
            default: new Footer({
              children: [
                new Paragraph({
                  alignment: AlignmentType.CENTER,
                  children: [
                    new TextRun({
                      text: `Generated: ${new Date().toLocaleString()}`,
                    }),
                    new TextRun({ text: "  •  " }),
                    new TextRun({ text: "Page " }),
                    PageNumber.CURRENT,
                  ],
                }),
              ],
            }),
          },
          children: docChildren,
        },
      ],
    });

    const buffer = await Packer.toBuffer(doc);
    fs.writeFileSync(filename, buffer);
    return filename;
  }


  async generateSeparate(outputDir = "output-files") {
    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const results = [];

    for (let i = 0; i < this.items.length; i++) {
      const item = this.items[i];

      const built = this._buildForItem(item);

      const doc = new Document({
        creator: this.creator,
        title: item.displayName || `Item ${i + 1}`,
        description: item.description || "",
        sections: [
          {
            properties: {},
            footers: {
              default: new Footer({
                children: [
                  new Paragraph({
                    alignment: AlignmentType.CENTER,
                    children: [
                      new TextRun({
                        text: `Generated: ${new Date().toLocaleString()}`,
                      }),
                      new TextRun({ text: "  •  " }),
                      new TextRun({ text: "Page " }),
                      PageNumber.CURRENT,
                    ],
                  }),
                ],
              }),
            },
            children: [
              built.title,
              built.subtitle,
              built.badge,
              built.description,
              built.detailsTable,
              built.note,
            ],
          },
        ],
      });

      const buffer = await Packer.toBuffer(doc);
      const safeName = (item.parameterName || `item-${i + 1}`).replace(
        /[\/:*?"<>|]/g,
        "_"
      );
      const fname = path.join(outputDir, `${safeName}.docx`);
      fs.writeFileSync(fname, buffer);
      results.push(fname);
    }

    return results;
  }
}

module.exports = { DocGenerator };

// Example usage when run directly
// if (require.main === module) {
//   const exampleItems = [
//     {
//       parameterType: "java.lang.Boolean",
//       isDefault: false,
//       displayName: "Audit automatic rejection of email approvals",
//       defaultValue: false,
//       description:
//         "Determines whether your site keeps a record of email approvals that were rejected automatically based on a check of the sender's email address. The audit information includes the email address from which the approval was sent, the name of the approver, the approvable involved, and the content of the message. SAP Ariba representatives can access the information.",
//       parameterName: "Application.Base.EmailApprovalAutoRejectAudit",
//       isCustomerEditable: true,
//       parameterValue: true,
//     },
//     {
//       parameterType: "java.lang.String",
//       isDefault: true,
//       displayName: "Sample string parameter",
//       defaultValue: "abc",
//       description: "A sample parameter used for demonstration.",
//       parameterName: "Application.Base.SampleString",
//       isCustomerEditable: false,
//       parameterValue: "xyz",
//     },
//   ];

//   (async () => {
//     try {
//       const gen = new DocGenerator(exampleItems, { creator: "Your Name" });
//       const combined = await gen.generateCombined("Combined-Parameters.docx");
//       console.log(`Saved combined file: ${combined}`);

//       const many = await gen.generateSeparate("./parameter-docs");
//       console.log(`Saved separate files:
//  - ${many.join('
//  - ')}`);
//     } catch (err) {
//       console.error("Failed to generate docs:", err);
//     }
//   })();
// }
